import trimesh
import numpy as np
from scipy.spatial.transform import Rotation as R
from trimesh.transformations import quaternion_about_axis, rotation_matrix, reflection_matrix, quaternion_from_matrix

class PoseFinder:
    def __init__(self, convex_hull_obj_file: str, self_obj_file: str, tolerance: float = 1e-5):
        """
        Initialize the PoseFinder with the convex hull OBJ file.
        :param convex_hull_obj_file: Path to the convex hull OBJ file.
        """
        self.mesh = trimesh.load_mesh(self_obj_file)
        self.convex_hull_mesh = trimesh.load_mesh(convex_hull_obj_file)

        # Ensure the mesh is centered around the centroid of the convex hull
        centroid = self.convex_hull_mesh.centroid

        self.convex_hull_mesh.apply_translation(-centroid)
        self.mesh.apply_translation(-centroid)

        # Compute full polygonal face hulls
        self.full_hull = self._compute_full_hull()

        #Initailze a numerical tolerance for grouping
        self.tolerance = tolerance

        # Check to ensure that the mesh and convex hull meshes are not empty
        if self.mesh.vertices is None or len(self.mesh.vertices) == 0:
            raise ValueError("Mesh vertices are not initialized or empty.")
        
        if self.convex_hull_mesh.vertices is None or len(self.convex_hull_mesh.vertices) == 0:
            raise ValueError("Convex hull mesh vertices are not initialized or empty.")
        
        if self.find_valid_rotations([(0, [1, 0, 0, 0])]) == []:
            raise ValueError("The initial rotation is invalid according to the geometric assumptions. Please check the convex hull mesh and the original mesh.")
    
    def _compute_full_hull(self):
        """
        Build full face polygons by grouping coplanar triangles from the convex hull mesh.
        Returns:
            - face_normals: (N, 3) array of outward face normals
            - face_centers: (N, 3) array of face center points
            - face_vertices: list of (M_i, 3) arrays of polygon boundary vertices
        """
        import numpy as np
        mesh = self.convex_hull_mesh
        normals = []
        centers = []
        polygons = []

        for facet, normal in zip(mesh.facets, mesh.facets_normal):
            submesh = mesh.submesh([facet], append=True, repair=False)
            boundary = submesh.outline()
            if boundary is None or len(boundary.vertices) < 3:
                continue

            normed_normal = normal / np.linalg.norm(normal)
            center = boundary.vertices.mean(axis=0)

            normals.append(normed_normal)
            centers.append(center)
            polygons.append(boundary.vertices)

        return np.array(normals), np.array(centers), polygons

    def find_candidate_rotations_by_edge_alignment(self):
        """
        Computes candidate rotations by aligning all unique polygon edge directions
        (from the full hull generated by `_compute_full_hull`) with one another.
        
        :return: A list of candidate rotations as quaternions.
        """
        faces = self._compute_full_hull()
        edge_dirs = []

        # Step 1: Extract normalized edge directions from all polygonal faces
        for _, vertices in faces:
            for i in range(len(vertices)):
                start = vertices[i]
                end = vertices[(i + 1) % len(vertices)]
                edge = np.array(end) - np.array(start)
                norm = np.linalg.norm(edge)
                if norm > 1e-6:
                    edge_dir = edge / norm
                    edge_dirs.append(edge_dir)

        # Step 2: Generate unique rotations aligning each edge to each other
        candidate_rotations = []
        seen_quats = set()
        candidate_count = 0

        for i, dir1 in enumerate(edge_dirs):
            for j, dir2 in enumerate(edge_dirs):
                axis = np.cross(dir1, dir2)
                norm_axis = np.linalg.norm(axis)

                if norm_axis < 1e-6:
                    dot = np.dot(dir1, dir2)
                    if dot > 0.999:
                        rotation = R.identity()
                    else:
                        # Rotate 180° around a perpendicular axis
                        perp = np.eye(3)[np.argmin(np.abs(dir1))]
                        axis = np.cross(dir1, perp)
                        axis /= np.linalg.norm(axis)
                        rotation = R.from_rotvec(axis * np.pi)
                else:
                    axis /= norm_axis
                    angle = np.arccos(np.clip(np.dot(dir1, dir2), -1.0, 1.0))
                    rotation = R.from_rotvec(axis * angle)

                quat = tuple(rotation.as_quat())
                if quat not in seen_quats:
                    seen_quats.add(quat)
                    candidate_rotations.append((candidate_count, np.array(quat)))
                    candidate_count += 1

        return candidate_rotations


    def find_candidate_rotations_by_face_normal_alignment(self):
            """
            Computes candidate rotations by aligning every face normal with every other face normal.
            :return: A list of candidate rotations as quaternions.
            """
            face_normals = self.convex_hull_mesh.face_normals
            candidate_rotations = []
            seen_rotations = set()
            candidate_count = 0

            for i, normal_1 in enumerate(face_normals):
                for j, normal_2 in enumerate(face_normals):
                    axis = np.cross(normal_1, normal_2)
                    norm_axis = np.linalg.norm(axis)

                    if norm_axis < 1e-6:
                        # Parallel or anti-parallel normals
                        dot = np.dot(normal_1, normal_2)
                        if dot > 0.999:  # Aligned
                            rotation = R.identity()
                        else:  # Opposite direction
                            # Any perpendicular axis is valid
                            perp_axis = np.eye(3)[np.argmin(np.abs(normal_1))]  # choose a non-collinear axis
                            axis = np.cross(normal_1, perp_axis)
                            axis /= np.linalg.norm(axis)
                            rotation = R.from_rotvec(axis * np.pi)
                    else:
                        axis /= norm_axis
                        angle = np.arccos(np.clip(np.dot(normal_1, normal_2) /
                                                (np.linalg.norm(normal_1) * np.linalg.norm(normal_2)), -1.0, 1.0))
                        rotation = R.from_rotvec(axis * angle)

                    quat = tuple(rotation.as_quat())  # round to avoid float issues
                    if quat not in seen_rotations:
                        seen_rotations.add(quat)
                        candidate_rotations.append((candidate_count, np.array(quat)))
                        candidate_count += 1

            return candidate_rotations
    
    def find_candidate_rotations_by_face_normal_verticies(self):
        """
        Generate rotation quaternions around each unique convex hull face normal.
        Rotation angles are based on internal angles between edges (irregular polygons supported).
        Returns a list of quaternions (w, x, y, z), including the identity.
        """
        quaternions = [(0, np.array([1.0, 0.0, 0.0, 0.0]))]  # Identity quaternion
        candidate_count = 1  # Initialize candidate count

        for normal, verts in self.full_hull:
            if len(verts) < 3:
                continue

            center = verts.mean(axis=0)
            tmp = np.array([1, 0, 0]) if abs(normal[0]) < 0.9 else np.array([0, 1, 0])
            x_axis = np.cross(tmp, normal)
            x_axis /= np.linalg.norm(x_axis)
            z_axis = np.cross(normal, x_axis)
            projection = np.stack([x_axis, z_axis]).T
            verts_2d = (verts - center) @ projection

            angles = -np.arctan2(verts_2d[:, 1], verts_2d[:, 0])
            angles = np.mod(angles, 2 * np.pi)
            sort_order = np.argsort(angles)
            verts_sorted = verts_2d[sort_order]
            angles_sorted = angles[sort_order]
            start_idx = np.argmin(angles_sorted)
            verts_sorted = np.roll(verts_sorted, -start_idx, axis=0)

            angle_steps = []
            n = len(verts_sorted)
            for i in range(n):
                a = verts_sorted[i - 1] - verts_sorted[i]
                b = verts_sorted[(i + 1) % n] - verts_sorted[i]
                a /= np.linalg.norm(a)
                b /= np.linalg.norm(b)
                dot = np.clip(np.dot(a, b), -1.0, 1.0)
                angle_steps.append(np.arccos(dot))

            cumulative_angle = 0.0
            for step in angle_steps:
                cumulative_angle += step
                quat = quaternion_about_axis(cumulative_angle % (2 * np.pi), normal)
                quaternions.append((candidate_count,quat))  # (w, x, y, z)
                candidate_count += 1
                print(f"  ↪ Rotation {candidate_count}: {np.degrees(cumulative_angle):.2f}°")

        return quaternions

    def find_candidate_rotations_by_resting_face_normal_alignment(self):
        """
        Aligns each face normal to the resting face normal (closest to -Z).
        Returns candidate rotations as quaternions.
        """

        face_normals, face_centers, vertices = self._compute_full_hull()
    
        resting_face_idx = np.argmin(np.dot(face_normals, np.array([0, 0, -1])))
        resting_normal = face_normals[resting_face_idx]
        candidate_rotations = [(0, np.array([1.0, 0.0, 0.0, 0.0]))]
        candidate_count = 1

        for i, normal in enumerate(face_normals):
            if i == resting_face_idx: #or np.allclose(normal, resting_normal):
                continue

            dot = np.clip(np.dot(normal, resting_normal), -1.0, 1.0)
            angle = np.arccos(dot)

            #if resting face is at the top, we need to extend the angle by 180 degrees to make sure its facing downwards
            if dot > 0:
                angle = (angle + np.pi) % (2 * np.pi)

           # Identity rotation
            if np.abs(angle) < 1e-6: 
                quat = np.array([1.0, 0.0, 0.0, 0.0])  
            # 180° rotation: axis undefined → use any axis orthogonal to normal
            elif np.abs(angle - np.pi) < 1e-6:
                ortho = np.array([1, 0, 0]) if abs(normal[0]) < 0.9 else np.array([0, 1, 0])
                axis = np.cross(normal, ortho)
                axis /= np.linalg.norm(axis)
                quat = R.from_rotvec(axis * angle).as_quat()
            else:
                axis = np.cross(normal, resting_normal)
                axis /= np.linalg.norm(axis)
                quat = R.from_rotvec(axis * angle).as_quat()

            candidate_rotations.append((candidate_count, quat))
            candidate_count += 1

        return candidate_rotations


    def find_candidate_rotations_by_resting_face_normal_verticies(self):
        """
        Generates in-plane rotations around the resting face normal (-Z).
        Returns a list of quaternions (w, x, y, z), including the identity.
        """
        quaternions = [(0, np.array([1.0, 0.0, 0.0, 0.0]))]
        candidate_count = 1

        # Find resting face (normal closest to -Z)
        for normal, verts in self.full_hull:
            if np.allclose(normal, [0, 0, -1], atol=1e-3):
                if len(verts) < 3:
                    break

                center = verts.mean(axis=0)
                tmp = np.array([1, 0, 0]) if abs(normal[0]) < 0.9 else np.array([0, 1, 0])
                x_axis = np.cross(tmp, normal)
                x_axis /= np.linalg.norm(x_axis)
                z_axis = np.cross(normal, x_axis)
                projection = np.stack([x_axis, z_axis]).T
                verts_2d = (verts - center) @ projection

                angles = -np.arctan2(verts_2d[:, 1], verts_2d[:, 0])
                angles = np.mod(angles, 2 * np.pi)
                sort_order = np.argsort(angles)
                verts_sorted = verts_2d[sort_order]
                angles_sorted = angles[sort_order]
                start_idx = np.argmin(angles_sorted)
                verts_sorted = np.roll(verts_sorted, -start_idx, axis=0)

                angle_steps = []
                n = len(verts_sorted)
                for i in range(n):
                    a = verts_sorted[i - 1] - verts_sorted[i]
                    b = verts_sorted[(i + 1) % n] - verts_sorted[i]
                    a /= np.linalg.norm(a)
                    b /= np.linalg.norm(b)
                    dot = np.clip(np.dot(a, b), -1.0, 1.0)
                    angle_steps.append(np.arccos(dot))

                cumulative_angle = 0.0
                for step in angle_steps:
                    cumulative_angle += step
                    quat = quaternion_about_axis(cumulative_angle % (2 * np.pi), [0, 0, -1])
                    quaternions.append((candidate_count, quat))
                    candidate_count += 1
                break

        return quaternions

    def find_candidate_rotations_by_fibonacci_sphere(self, axis_samples=20, angle_samples=12):
        """
        Generate a list of candidate rotation quaternions.
        First entry is the identity quaternion.
        :param axis_samples: Number of candidate axes (from Fibonacci sphere).
        :param angle_samples: Number of rotation orders to generate (2 to 2+angle_samples).
        :return: List of quaternions (w, x, y, z).
        """
        from trimesh.transformations import quaternion_about_axis
        candidates = [(0, np.array([1.0, 0.0, 0.0, 0.0]))]  # Identity rotation
        candidate_count = 1

        # Fibonacci sphere for axis sampling
        i = np.arange(0, axis_samples)
        phi = np.arccos(1 - 2*(i + 0.5)/axis_samples)
        theta = np.pi * (1 + 5**0.5) * (i + 0.5)
        axes = np.stack([
            np.sin(phi) * np.cos(theta),
            np.sin(phi) * np.sin(theta),
            np.cos(phi)
        ], axis=1)

        for axis in axes:
            axis = axis / np.linalg.norm(axis)
            for order in range(2, angle_samples + 2):  # e.g. 2, 3, 4, ...
                angle = 2 * np.pi / order
                for i in range(1, order):  # Skip 0 rotation (identity)
                    quat = quaternion_about_axis(i * angle, axis)
                    candidates.append((candidate_count,quat))  # (w, x, y, z)
                    candidate_count += 1

        return candidates


    def find_valid_rotations(self, candidate_rotations):
        """
        Filters candidate rotations to find valid rotations where at least three external vertices
        of the convex hull would intersect two 90-degree intersecting planes.
        :param candidate_rotations: A list of candidate rotations as quaternions.
        :return: A list of valid rotations as tuples (index, quaternion).
        """
        vertices = np.array(self.convex_hull_mesh.vertices)
        valid_rotations = []

        count = 0

        for index, quat in candidate_rotations:
            rotation = R.from_quat(quat)
            rotated_vertices = rotation.apply(vertices)

            # --- Bin by z ---
            binned_z = np.round(rotated_vertices[:, 2] / self.tolerance) * self.tolerance
            min_z = np.min(binned_z)
            min_z_indices = np.where(binned_z == min_z)[0]

            # --- x–y plane check (same z) ---
            x_plane_count = np.count_nonzero(binned_z == min_z) >= 3

            # --- x-plane for y–z: check for min_x in each x-bin ---
            binned_x = np.round(rotated_vertices[:, 0] / self.tolerance) * self.tolerance
            min_x = np.min(binned_x)
            min_x_indices = np.where(binned_x == min_x)[0]

            # --- y–z plane check for the values that passed the x-y plane check (same x) ---
            y_plane_count = 0
            for idx in min_x_indices:
                if np.count_nonzero(binned_z[min_x_indices] == binned_z[idx]) >= 2:
                    y_plane_count += 1
                    break

            if x_plane_count and y_plane_count:
                valid_rotations.append((count, quat))
                count += 1

        return valid_rotations
    
    def duplicate_remover(self, rotations):
        """
        Handles duplicate rotations by removing rotations that are too close to each other.
        :param rotations: List of tuples (pose, valid rotation vector).
        :return: List of tuples (assigned pose, valid rotation vector).
        """
        unique_rotations = {}
        assigned_rotations = []
        pose_count = 0

        for index, quat in rotations:
            rounded_quat = tuple(np.round(quat, decimals=int(np.log10(1/self.tolerance))))  # Round to prevent numerical noise
            one_zero_rounded_quat = tuple(0.0 if abs(x) < self.tolerance else x for x in rounded_quat)  # Ensure all zeros are positive
            if one_zero_rounded_quat not in unique_rotations:
                unique_rotations[one_zero_rounded_quat] = index
                assigned_rotations.append((pose_count, one_zero_rounded_quat))
                pose_count += 1
        
        return assigned_rotations
    
    def symmetry_handler(self, rotations):
        """
        Handles symmetry constraints by sorting by pose and assigning the same pose to symmetrically equivalent rotations.
        This is done by checking if the rotation has multiple rotatationally symmetrically equivalent representations.
        :param rotations: List of tuples (pose, valid rotation vector).
        :return: List of tuples (assigned pose, valid rotation vector).
        """
        assigned_rotations = []
        assymetric_pose_count = 0

        for index, quat in rotations:
            # Check if the rotation is already assigned to a pose
            if not any(np.array_equal(quat, assigned_quat) for _, assigned_quat in assigned_rotations):
                assigned_rotations.append((assymetric_pose_count, quat))

                # Check if the rotation has multiple representations equivalent by rotational symmetry
                rotation = R.from_quat(quat)
                rotated_vertices = rotation.apply(self.mesh.vertices)

                for check_index, check_quat in rotations:
                    if check_index != index:
                        check_rotation = R.from_quat(check_quat)
                        check_rotated_vertices = check_rotation.apply(self.mesh.vertices)

                        sorted_rotated_vertices = np.sort(rotated_vertices, axis=0)
                        sorted_check_rotated_vertices = np.sort(check_rotated_vertices, axis=0)

                        # Do is close as the vertices have a slight numerical noise when the rotation is applied
                        is_close = np.allclose(sorted_rotated_vertices, sorted_check_rotated_vertices, atol=1e-5, rtol=0.0)

                        if is_close:
                            # Append the rotation with the same pose count if it is rotationally symmetric
                            assigned_rotations.append((assymetric_pose_count, check_quat))
                
                assymetric_pose_count += 1

        return assigned_rotations
